{
  "id": "9b04ed86c19d4fbea02020533a613471",
  "title": "Using Enums in TypeScript",
  "createDate": 1680147991871,
  "guid": "5090e747-341f-40d3-bb8c-031df65615c5",
  "author": "Xiwen Tu, Yifeng Wang , Fanjing Zhang",
  "tags": [
    "Letâ€™s make XXX"
  ],
  "slug": "using-enums-in-typescript",
  "description": "This article is not intended to teach you how to use enums in Typescript, but rather to discuss the problems of using them in real-world scenarios, based on our experiences and some references",
  "created": 1658361600000,
  "updated": 1658361600000,
  "layout": "blog",
  "publish": true,
  "authors": [
    "Xiwen Tu",
    "Yifeng Wang",
    "Fanjing Zhang"
  ],
  "cover": "https://app.affine.pro/api/workspaces/qf73AF6vzWphbTJdN7KiX/blobs/60aGg896GQKbuzYJRNeeD49qPmLW0rn8nqNn5xTcXpY=",
  "coverAlt": "",
  "md": "## Prelude\n\n\nThis article is not intended to teach you how to use enums in Typescript, but rather to discuss the problems of using them in real-world scenarios, based on our experiences and some references.\n\n\nNote that [link](https://www.typescriptlang.org/play?#code/PTAEHUFMBsGMHsC2lQBd5oBYoCoE8AHSAZVgCcBLA1UABWgEM8BzM+AVwDsATAGiwoBnUENANQAd0gAjQRVSQAUCEmYKsTKGYUAbpGF4OY0BoadYKdJMoL+gzAzIoz3UNEiPOofEVKVqAHSKymAAmkYI7NCuqGqcANag8ABmIjQUXrFOKBJMggBcISGgoAC0oACCoASMFmgY7p7ehCTkVOle4jUMdRLYTqCc8LEZzCZmoNJODPHFZZXVtZYYkAAeRJTInDQS8po+rf40gnjbDKv8LqD2jpbYoACqAEoAMsK7sUmxkGSCc+VVQQuaTwVb1UBrDYULY7PagbgUZLJH6QbYmJAECjuMigZEMVDsJzCFLNXxtajBBCcQQ0MwAUVWDEQNUgADVHBQGNJ3KAALygABEAAkYNAMOB4GRogLFFTBPB3AExcwABT0xnM9zsyhc9wASmCKhwDQ8ZC8iElzhB7Bo3zcZmY7AYzEg-Fg0HUiS58D0Ii8AoZTJZggFSRxAvADlQAHJhAA5SASAVBFQAeW+ZF2gldWkgx1QjgUrmkeFATgtOlGWH0KAQiBhwiudokkuiIgMHBx3RYbC43CCJSAA) marks a hyperlink to TypeScript Playground for checking out examples.\n\n\n## Introducing Enums\n\n\nEnums are provided by TypeScript to define constants with names that clearly express intent, or to create a set of distinguished cases.\n\n\nThe value and type of an enum are one and the same, and the type of an enum member is a subtype of that enum type. There are two scenarios to be aware of when defining enums.\n\n\n* When all enum members are literal enum values, all of these members are both values and types.\n\n\n* If there are non-literal members in the enum, then all members of that enum can only be used as values.\n\n\n```typescript\n/* enum members are all literal values */\nenum Day {\n  Monday,\n  Tuesday,\n  Wednesday,\n}\n\nconst monday: Day = Day.Monday; // valid ðŸ˜Ž\nconst thusday: Day.Tuesday = Day.Tuesday; // valid ðŸ˜Ž\n\n/* enum members contain non-literal enum values */\nenum NextDay {\n  Monday,\n  Tuesday,\n  Wednesday = Day.Wednesday /* non-literal enum values */,\n}\n\nconst nextMonday: NextDay = NextDay.Monday; // valid ðŸ˜Ž\nconst nextThusday: NextDay.Tuesday = NextDay.Tuesday; // invalid ðŸ˜“\nconst nextWednesday: NextDay.Wednesday = NextDay.Wednesday; // invalid ðŸ˜“\n\n```\n\n\nYou can see that Day and NextDay are compiled into JavaScript with exactly the same structure ([link](https://www.typescriptlang.org/play?#code/PQKgBIWeaHxygIRoGiqF+Ew9GaHVtQRumHnE6geBTCYAUAKYB2ArgLZgAiAhgJ5gDeBYbYAsgPYkAmDAGlbsAKmSIBnfvSHswAdSK8Sk6UIC+AbgIEAxjwkAXMBR7SAXDQZgAvFfoA6bnwaawwYGAButADYBLXj0DY0MACzIpBks6RzFVaztYh3io+jcPbz9AnQJQSFg4QFBlQGoVQD109CwoXHxicioAOSIAD0NY5mE2ZzVOsFSeuUVlBMYkhgchlTSBd08KzBwCLR19EiMwFVbu6LAm1va7Pbbx7fTZrICg1fXNwxEItMsj5P7E3ZbjuPE0jM9-Eh8l2Ca2Mt0mIyeH2S4LStne+3GMOkvzA-0BgSAA)).\n\n\n```typescript\nvar Day;\n(function (Day) {\n  Day[(Day[\"Monday\"] = 0)] = \"Monday\";\n  Day[(Day[\"Tuesday\"] = 1)] = \"Tuesday\";\n  Day[(Day[\"Wednesday\"] = 2)] = \"Wednesday\";\n})(Day || (Day = {}));\n\nvar NextDay;\n(function (NextDay) {\n  NextDay[(NextDay[\"Monday\"] = 0)] = \"Monday\";\n  NextDay[(NextDay[\"Tuesday\"] = 1)] = \"Tuesday\";\n  NextDay[(NextDay[\"Wednesday\"] = 2)] = \"Wednesday\";\n})(NextDay || (NextDay = {}));\n\n```\n\n\n## Fundamentals of Enums\n\n\nFirstly in JavaScript, we generally tend to use objects for defining constant configurations. But in TypeScript, defining these constants with enums can be more terse and expressive.\n\n\n```typescript\n/* JS: Constants Config */\nconst SERVICE_STATUS = {\n  SUCCESS: 200,\n  NOT_FOUND: 404,\n  UNKONW_ERROR: 500,\n};\n\n/* TS: Enum Config */\nenum SERVICE_STATUS {\n  SUCCESS = 200,\n  NOT_FOUND = 404,\n  UNKONW_ERROR = 500,\n}\n\n```\n\n\nThen, different definitions of enums leads to different behaviors and different compiled JavaScript output.\n\n\nFor example, here is an enum definition ([link](https://www.typescriptlang.org/play?#code/KYOwrgtgBAIghgTygbwFBQ1AsgexAE0SgF4oByCPQhMgGnUwBUxgBnak8gFxfcToYYA6sHwg2HUmQDuo8Xxr0AvgG5UqAMZ5WXKNQBcsIqXgIAdLgKIVQA)).\n\n\n```typescript\nenum Day {\n  Monday = \"monday\",\n  Tuesday = \"tuesday\",\n  Wednesday = \"wednesday\",\n}\n\nconst day: Day = Day.Monday;\n\n```\n\n\nIts corresponding JavaScript compiled output looks like this.\n\n\n```typescript\nvar Day;\n(function (Day) {\n  Day[\"Monday\"] = \"monday\";\n  Day[\"Tuesday\"] = \"tuesday\";\n  Day[\"Wednesday\"] = \"wednesday\";\n})(Day || (Day = {}));\n\nconst day = Day.Monday;\n\n```\n\n\nSo we can see in JavaScript, enums are converted to objects, and two-way mappings are added inside the objects, which undoubtedly increases size of the bundle.\n\n\nAs a comparison, we can take a look at the result of using theconst enum definition ([link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBApmArgWxgEQIYE8YG8BQMRMAsuACbYwC8MA5MhdnQDSHEAqicElOtdKN17M2xGAHU45MDz416Ad2myRWVvgC+Abnz5QkWHwBc6KrUxYAdGTB9tQA)).\n\n\n```typescript\nconst enum Day {\n  Monday = \"monday\",\n  Tuesday = \"tuesday\",\n  Wednesday = \"wednesday\",\n}\n\nconst day: Day = Day.Monday;\n\n```\n\n\nWhen the above code is compiled into JavaScript in strict mode, the constant enum definition is removed and its members are replaced with corresponding inlined values.\n\n\n```typescript\n\"use strict\";\n\nconst day = \"monday\"; /* Day.Monday */\n\n```\n\n\nSo itâ€™s clear that enums defined by const enum in TypeScript are more likely to be used as values (inferred from the compiled JavaScript results). Whereas enums defined with enum can be used as both values and types.\n\n\nLast thing to note is that two enums cannot be assigned to each other, even if their members are identical ([link](https://www.typescriptlang.org/play?#code/KYOwrgtgBAIghgTygbwFBQ1AsgexAE0QBp1MAVMYAZ0IRMygHVh8RraSBfAblVVEhQAcsAAeAF3hI0DXAWKkMFdgobNWKuqh58AxniriotAFyxEUALzmEAOjm1uUAPTOoANzgAbAJb4ogLwbgHB7wcF6BkZsEg6IZlL2eLRWwmKSiAnyCE6uUD4gnr7+AYC0eyUlqPoghlBR4so0sSkS8fVJ1iLN6a2I2W4FfoEhQ0A)).\n\n\n```typescript\nenum Day {\n  Monday,\n  Tuesday,\n  Wednesday,\n}\n\nenum NextDay {\n  Monday,\n  Tuesday,\n  Wednesday,\n}\n\nconst day: Day = Day.Monday; // valid ðŸ˜Ž\n\nconst nextMonday: Day.Monday = NextDay.Monday; // invalid ðŸ˜­\nconst nextTuesday: NextDay.Tuesday = NextDay.Tuesday; // valid ðŸ˜Ž\n\n```\n\n\n## Caveats\n\n\nUsing enums as types can lead to some confusing behavior.\n\n\nFirstly, in the world of [structural typing](https://en.wikipedia.org/wiki/Structural_type_system), enums sticks to [nominal typing](https://en.wikipedia.org/wiki/Nominal_type_system). This means that even if one value is valid and compatible, it canâ€™t be passed to a function or object that requires a string enum ([link](https://www.typescriptlang.org/play?#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQDkYJVANAbBgO7aVUAmrIDTAMsABmqCtQA2w1H0IAlOAHMAFqI4JFKvgF88eTinEBDJFCFgQaTNnEYF8JJawAKTohTosALlhvHIAJTeAG4YcJwA3Lo2dr4eIE40dP7hUAD0qVBwIEGG4mFQgHwbgCi7xaUl5VG29u5WTtV+AHSkyWkZOXmcQA)).\n\n\n```typescript\nenum Direction {\n  Up = \"up\",\n  Down = \"down\",\n  Left = \"left\",\n  Right = \"right\",\n}\n\ndeclare function logDirection(direction: Direction): void;\n\nlogDirection(\"up\"); // invalid ðŸ¤”\n\nlogDirection(Direction.Up); // valid\n\n```\n\n\nWhat if we replace it with a JavaScript constant object ([link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBAIgSwE4FNhQeGBeGBvAKBhgFUAHALhgHIBXM6gGiPhAHcwrqATdsJlgBkUAMyhcANqKgDiAJQQBzABbiaSJaoEBfGAEMIMUJCgBuAgSgBPMihgA1PRNooA8iIA8AFQB8OGF4A2gDWKFYgIgEAuuYE3GgSeqgwIrRg6JhgMBIgioioGeAAFNzIaBjgVI7Obp7WthHwZYVgPgCUVABuIAjcsTl5zRVgRXQMbaYwAPRTMJ1OvTCAvBuAIHur62ubFgP55ZlFuy0AdOQT07PzEr1AAA))?\n\n\n```typescript\nconst Direction = {\n  Up: \"up\",\n  Down: \"down\",\n  Left: \"left\",\n  Right: \"right\",\n} as const;\n\ntype ValueOf<T> = T[keyof T];\n\ndeclare function logDirection(direction: ValueOf<typeof Direction>): void;\n\nlogDirection(\"up\"); // valid ðŸ˜„\n\nlogDirection(Direction.Up); // valid\n\n```\n\n\nIf the value of one enum member is a numeric literal, then the type of that enum will be widen to number ([link](https://www.typescriptlang.org/play?ssl=11&ssc=36&pln=1&pc=1#code/KYOwrgtgBAygogJQGoEkDCcD6MAqBBHAVRigG8AoKWQtDGEgXigCYAGVgGkqgDkB5HJgBifQjwAiUJgBZW0rlTEBpPjwDqmRAj4IpUAKzsuAXwDc5cgGMA9iADOAFygBzYA7TWAJsD0AKG94AXLCIqBjY+EQwAJRSAHxQAcDm5K7uXsC+bKzRplAA9PlQAG4AhgA2AJaeFmke3r4AjMwAzLkFRWVVnlCAvBuATHsDQ4MjQA)).\n\n\n```typescript\nenum SERVICE_STATUS {\n  SUCCESS = 200,\n  NOT_FOUND = 404,\n  UNKONW_ERROR = 500,\n}\n\nconst getCode = (code: SERVICE_STATUS) => code;\n\ngetCode(200); // valid\n\ngetCode(123); // valid ðŸ˜²\n\n```\n\n\nWhat if we replace it with a JavaScript constant object ([link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBAygUQEoDUCSBhBB9OAVAQTwFU4YBeGAbwCgZ75iMs44AuGAJgAZuAaOgwByAeTzYAYiOJCAIhwAs3BQIYwZAaRFCA6tmRIRSDgFZefGDQC+MAIYQYoSFADcNGlACeABwCmMFFsAGwBXXxEAMwAePAA+Chg8AG0Aa19PEAjEgF0XSxonaBgAc18oDBAAE39KAApQao5A0PDorz9M+GR0LFxCEjhYgEoKeIbfN1Lyqt9anm4hvIB6JZgAN2CAS0r3KYrq2oBGTgBmRZgVmE2wDaDtmEBeDcAQPefXl-egA))?\n\n\n```typescript\nconst SERVICE_STATUS = {\n  SUCCESS: 200,\n  NOT_FOUND: 404,\n  UNKONW_ERROR: 500,\n} as const;\n\ntype ValueOf<T> = T[keyof T];\n\nconst getCode = (code: ValueOf<typeof SERVICE_STATUS>) => code;\ngetCode(200); // valid\n\ngetCode(123); // invalid ðŸ˜„\n\n```\n\n\nHeterogeneous enums (enum whose member types are different) can lead to weird behavior ([link](https://www.typescriptlang.org/play?#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADgDQGwYDuIFhAMsAGar1QBKcA5gBapQAvFADkCHvxEUAvgG48eZFgDOAgDYZu8JGkzZhACgAmiFOiwAuWKd1YAlEIB8UEzvMh5eDVpvuD2sz0AOlI7WSgAegioADcAQzU4Iy9NANsQf19grj5UMMjo+MTk7zS-MQlUEXyoqDgQIqSoQF4NwDo9to72rpSfNz0DAEYABiGawoSm5sBGPenZmfmgA)).\n\n\n```typescript\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right = \"right\",\n}\n\nconst logDirection = (direction: Direction) => direction;\n\nlogDirection(Direction.Up); // valid\nlogDirection(Direction.Right); // valid\nlogDirection(\"right\"); // invalid ðŸ˜®\nlogDirection(100); // valid ðŸ˜±\n\n```\n\n\nWhat if we replace it with a JavaScript constant object ([link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBAIgSwE4FNhQeGBeGBvAKBhgFUAHALhgAYAaI+EAdzCoEZ7iAZFAMyioAmTjABKCAOYALATADkSSTLn0AvjACGEGKEhQA3AQJQAnmRQwAahoA2AVxQB5XgB4AKgD4cMNwG0A1igmILw+ALr6MEa60DA2IBKIqOiYYN4AFAAmyGgY4FTW9k6upuYh8Dkp4B4AlDhe2cl5YIYE8YmVzelJuakAdOQ1kQD0wzAAbrYImW0JPVVg3Z394tJQQzCjE1Mz7fNdCkpQchtbkzbTVAC2KCiwKAAe5ugazdqAvBuAcHtfP99-sx0mql0mxqNRTmMEGBzpcYDc7jBHs8oK9Uh9AIx770x2KxWKAA))?\n\n\n```typescript\nconst Direction = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: \"right\",\n} as const;\n\ntype ValueOf<T> = T[keyof T];\n\nconst logDirection = (direction: ValueOf<typeof Direction>) => direction;\n\nlogDirection(Direction.Up); // valid\nlogDirection(Direction.Right); // valid\nlogDirection(\"right\"); // valid ðŸ˜Ž\nlogDirection(100); // invalid ðŸ˜±\n\n```\n\n\nThen, enums used in TypeScript canâ€™t be [tree shaked](https://medium.com/@netxm/what-is-tree-shaking-de7c6be5cadd) when compiled into JavaScript, because itâ€™s [compiled into IIFE](https://stackoverflow.com/questions/68720866/why-does-webpack-5-include-my-unused-typescript-enum-exports-even-when-tree-sha).\n\n\nTo be clear, enums can be used to define some constants with names. But if the constants are required to be objects (e.g. complex configuration items), enums are obviously not sufficient to handle them ([link](https://www.typescriptlang.org/play?ssl=23&ssc=1&pln=1&pc=1#code/PQKgBIScaPF6gjkYmEphMAUAYwPYDsDOAXMAwugDbECGuAllmALxgDeyYLYAggMoEBcjzrAgNYBTAJ68A5JwISANPwEsAbmWIBXYbwCM8gQF9drACIBRLryaLWI8WAmmuchYpXrNYAEyGWB5HrBk2GAYOLgA3MjIoGCAWdqAknKA3j6A0eqIKLiiAA7CYABqqhoA8gBmADwAKgB8dGBlANo26EU1ALoRUeCAOvKAXHKAsomAdv6AnhmA-vKAFK6pyOlZhCTkVDT0eW7FJZPCjdOkFNSYFW0heMEzW1gFGXM4vESb57XN1QUARgBWwqi4AHSuGtgAFFez2wAlG1ot1ABt5gBLowA8CqNxqsNgCsIsNNUfsjhMtVut-scdoDahIvsIJK1Ivt8Kg1AAnKnCTC4dGXI7ndHVHHnd7ST75YRhIA)).\n\n\n```typescript\n/* sorting rules */\nconst Collation = {\n  ASC: {\n    key: \"ASC\",\n    value: 1,\n  },\n  DESC: {\n    key: \"DESC\",\n    value: 2,\n  },\n} as const;\n\n/* define types */\ntype ValueOf<T> = T[keyof T];\n\n/* use it as configurations */\ntype Collation = ValueOf<typeof Collation>;\n\nconst collationOptions: Collation[] = Object.values(Collation);\n\n/* use it as default values */\ntype CollationValue = ValueOf<typeof Collation>[\"value\"];\n\nconst currentValue: CollationValue = Collation.ASC.value;\n\n```\n\n\n## Takeaways\n\n\nTypeScript has many advantages over JavaScript:\n\n\n1. Interface-oriented development brings great extensibility.\n\n\n1. Static type checking can help developers write more robust code, significantly improving code quality and comprehensibility. Types are one of the best forms of documentation.\n\n\n1. Code integrity and intelligent awareness, which can be one of the biggest advantages.\n\n\nTypeScript enums can clearly define simple configuration, its existence is reasonable, but not necessarily the most appropriate. The overall optimal solution is not always also the local optimal solution.\n\n\nBased on the above analysis, we also see many defects (or designed features) of TypeScript enums, even when the source code is not compiled into JavaScript. In practice, then, it is possible to choose the best - using constant objects instead of enums when necessary. What we propose can make it possible to:\n\n\n* Making types more rigorous and reliable.\n\n\n* Allowing complex configuration items to complete the loop in daily use.\n\n\n",
  "valid": true
}